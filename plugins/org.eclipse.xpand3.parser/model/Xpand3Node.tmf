grammar Xpand3Node;

normalizable file  :
	(imp+=nsImport)*
	(decl+=abstractDeclaration )*
	 EOF
;

nsImport:
	LG 'IMPORT' ns=simpleType RG |
	LG 'EXTENSION' ns=simpleType RG |
	'import' type  ';' | 
	'extension' type ('reexport')? ';' 
;

abstract normalizable abstractDeclaration :
	check |
	around |
	extension |
	definition |
	definitionAround
;

// XPAND start

definition :
	LG DEFINE name=identifier ('(' (declaredParameterList (','? '*')? | '*')? ')')? 'FOR' type
	sequence
	ENDDEFINE RG
;
	
definitionAround :	
	LG AROUND pointcut ('(' (declaredParameterList (','? '*')? | '*')? ')')? 'FOR' type
	sequence
	ENDAROUND RG
;	

sequence :
	 textSequence 
	 (statement 
	  textSequence)*		
;

abstract normalizable statement :
  simpleStatement 
| fileStatement 
| foreachStatement 
| ifStatement 
| letStatement 
| protectStatement
;
	
normalizable textSequence :
	text (text)*
;

text :
	'-'? TEXT
;

abstract normalizable simpleStatement :
  errorStatement
| expandStatement
| expressionStmt
;

errorStatement :
  'ERROR' expression
;

expandStatement :
  'EXPAND' simpleType ('(' parameterList ')')? (('FOR' expression)
  | ('FOREACH'expression ('SEPARATOR' expression)?))?
;

expressionStmt  :
	expression
;

fileStatement :
	'FILE' expression (identifier)?
		sequence 
	'ENDFILE'
;
	
foreachStatement :
	 'FOREACH' expression 'AS' identifier ('ITERATOR' identifier)? ('SEPARATOR' expression)?
  		sequence 
	 'ENDFOREACH'
;

ifStatement : 
     'IF' expression
		sequence 
	 elseIfStatement*
	 elseStatement?
	 'ENDIF'
;

elseIfStatement :
	'ELSEIF' expression
		sequence 
;
	
elseStatement :
	'ELSE'
		sequence
;
	
letStatement :
	 'LET' expression 'AS' identifier
  		sequence 
	 'ENDLET'
;
	
protectStatement :
	'PROTECT' 
		'CSTART' expression 
		'CEND' expression 
         	'ID' expression 'DISABLE'?
 		sequence 
	'ENDPROTECT'
;

// Xtend start

check :
	'context' type ('if' expression)? ('ERROR'|'WARNING') expression ':'
		expression ';'	
;

around  :
    'around' pointcut '(' (declaredParameterList (','? '*')? | '*')? ')' ':'
    	expression ';'
;
    
pointcut  :
	( '*' 
	 |identifier)
	  ( '*' 
	   |identifier 
	   |'::' )*
;

extension  : // TODO create <identifier> <name< (...)
	(private='private'|cached='cached'|create='create')* returnType=type? name=identifier '(' paramList=declaredParameterList? ')' ':'
		('JAVA' javaReturnType=javaType '.' javaName=identifier '('(javaType (',' javaType )*)? ')'|	
			extendBody=expression )';'
;

javaType  :
	identifier  
	('.' (identifier |'Collection' | 
	'List' |'Set'))*
;

//
// Expressions
//

normalizable test_expression:	
 	expression EOF
;

normalizable expression :
	letExpression
;

normalizable letExpression  :
   'let' identifier '=' castedExpression ':' expression 
|  castedExpression 
;

normalizable castedExpression :
    =>('(' type ')' chainExpression)
	'(' type ')' chainExpression 
	| chainExpression 
;

normalizable chainExpression  :
	ifExpression  ( '->' ifExpression )*
;

normalizable ifExpression  :
	switchExpression ('?' expression ':' switchExpression )?
|	'if' expression 'then' switchExpression ('else' switchExpression)? 
;

normalizable switchExpression  :
   'switch' ('(' orExpression ')')? '{'
	casePart*
   'default' ':' orExpression
   '}'
|  orExpression 
;

casePart :
	'case' expression ':' expression;	

normalizable orExpression :
  	andExpression  ('||' andExpression )*	
;

normalizable andExpression 	:
	impliesExpression  ('&&' impliesExpression 	)*	
;

normalizable impliesExpression :
	relationalExpression  ('implies' relationalExpression 	)*	
;
	
normalizable relationalExpression :
	leftOperand=additiveExpression 
	(operator=booleanOperator rightOperand=additiveExpression )*
;

booleanOperator :
		'==' 
	| '!=' 
	| '>=' 
	| '<=' 
	| '>' 
	| '<';
	
normalizable additiveExpression :
	multiplicativeExpression 
   (('+'| '-') multiplicativeExpression )*
;

normalizable multiplicativeExpression :
	unaryExpression 
	(('*' | '/') unaryExpression )*
;


normalizable unaryExpression :
	infixExpression 
|	'!' infixExpression	
|	'-' infixExpression	
;

normalizable infixExpression :
	target=primaryExpression  ( '.' calls+=featureCall )*
;
	
abstract normalizable primaryExpression 	 :
    stringLiteral 	
|   featureCall 
|   booleanLiteral 
|   numberLiteral 
|   nullLiteral 
|   listLiteral 
|   constructorCall 
|   globalVarExpression 
|   paranthesizedExpression 
;

stringLiteral :
   StringLiteral
;

paranthesizedExpression :
    '(' expression ')' 
;

globalVarExpression  :
    'GLOBALVAR' identifier ;

normalizable featureCall  :
    name=identifier '(' (paramList=parameterList)? ')' 
|   type 	
|   collectionExpression 
;

listLiteral  :
	'{'(expression (',' expression)*)?'}'
;

constructorCall  :
	'new' simpleType
	
;

booleanLiteral  :
	'false'|'true'
;

nullLiteral  :
	'null'
;

numberLiteral  :
  	IntLiteral 
| 	IntLiteral '.' IntLiteral 
;

collectionExpression  :
  'typeSelect'
  '(' type ')' 
  
  |('collect'
  | 'select' 
  | 'selectFirst' 
  | 'reject' 
  | 'exists'
  | 'notExists'
  | 'sortBy' 
  | 'forAll') '(' (identifier '|')? expression ')' 
 
;

// helper

declaredParameterList  : 
	params+=declaredParameter (',' params+=declaredParameter )*
;

declaredParameter :
	ptype=type name=identifier 
;

parameterList  :
    params+=expression  (',' params+=expression )* 
;

// type

abstract normalizable type : 
	collectionType |
	simpleType 
;
	
collectionType  : 
  ( 'Collection' | 'List' | 'Set' ) 
  ('[' simpleType ']' )?
;

simpleType :
	names+=identifier 
	('::' names+=identifier  )*
;

identifier :
   Identifier 
;


/////////////////////////////////////////
// LEXER
////////////////////////////////////////

lexer IntLiteral :
	<# ('0' | '1'..'9' '0'..'9'*) #>
	
lexer StringLiteral :  
	<# '\"' ( EscapeSequence | ~('\\'|'\"') )* '\"'
    |  '\'' ( EscapeSequence | ~('\''|'\\') )* '\'' #>

lexer fragment EscapeSequence    :
	<# '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
    |   UnicodeEscape
    |   OctalEscape #>

lexer fragment OctalEscape :   
	<# '\\' ('0'..'3') ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') ('0'..'7')
    |   '\\' ('0'..'7') #>

lexer fragment UnicodeEscape :
    <# '\\' 'u' HexDigit HexDigit HexDigit HexDigit #>
    
lexer fragment HexDigit : 
	<# ('0'..'9'|'a'..'f'|'A'..'F') #>

lexer DEFINE 	: 
	<# {xpandMode=true;}	 'DEFINE' #>

lexer ENDDEFINE :
	<# 'ENDDEFINE' {xpandMode=false;} #>
	
lexer AROUND 	:	
	<# {xpandMode=true;}'AROUND' #>

lexer ENDAROUND :	<# 'ENDAROUND'{xpandMode=false;} #> 

lexer Identifier : 
	<# ('^')? Letter (Letter|JavaIDDigit)* #>

lexer fragment Letter :
    <# '\u0024' |
       '\u0041'..'\u005a' |
       '\u005f' |
       '\u0061'..'\u007a' |
       '\u00c0'..'\u00d6' |
       '\u00d8'..'\u00f6' |
       '\u00f8'..'\u00ff' |
       '\u0100'..'\u1fff' |
       '\u3040'..'\u318f' |
       '\u3300'..'\u337f' |
       '\u3400'..'\u3d2d' |
       '\u4e00'..'\u9fff' |
       '\uf900'..'\ufaff' #>

lexer fragment JavaIDDigit :  
	<#
       '\u0030'..'\u0039' |
       '\u0660'..'\u0669' |
       '\u06f0'..'\u06f9' |
       '\u0966'..'\u096f' |
       '\u09e6'..'\u09ef' |
       '\u0a66'..'\u0a6f' |
       '\u0ae6'..'\u0aef' |
       '\u0b66'..'\u0b6f' |
       '\u0be7'..'\u0bef' |
       '\u0c66'..'\u0c6f' |
       '\u0ce6'..'\u0cef' |
       '\u0d66'..'\u0d6f' |
       '\u0e50'..'\u0e59' |
       '\u0ed0'..'\u0ed9' |
       '\u1040'..'\u1049'
       #>

lexer WS  :  
	<# (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;} #>

lexer COMMENT :   
	<# '/*' ( options {greedy=false;} : . )* '*/' {$channel=HIDDEN;} #>

lexer LINE_COMMENT : 
	<# '//' ~('\n'|'\r')* ('\r'? '\n'|EOF) {$channel=HIDDEN;} #>
    
    
lexer REM_COMMENT_OUT :
	<# {!xpandMode}?=> LG 'REM' RG ( options {greedy=false;} : . )* '\u00ABENDREM' RG {$channel=HIDDEN;} #>
    
lexer REM_COMMENT :
	<# {xpandMode}?=> 'REM' RG ( options {greedy=false;} : . )* '\u00ABENDREM' {$channel=HIDDEN;} #>

lexer TEXT :
	<# {xpandMode}?=> RG ~(LG)* (LG)? #>

lexer LG 	: 
	<# '\u00AB' #>
	
lexer RG	: 
	<# '\u00BB' #>	
